const { expect } = require("chai");
const { ethers, network } = require("hardhat");

const convert = (amount, decimals = 18) => ethers.utils.parseUnits(amount.toString(), decimals);

describe("Rig Exploit Attempts", function () {
    let WETH, DONUT, uniFactory, uniRouter, rigFactory, auctionFactory, core, multicall;
    let owner, user0, user1, user2, attacker, treasury, team;
    let rig, unit, auction, lpToken;

    const PRECISION = ethers.BigNumber.from("1000000000000000000"); // 1e18

    async function getFutureDeadline() {
        const block = await ethers.provider.getBlock("latest");
        return block.timestamp + 3600;
    }

    async function mineBlocks(n) {
        for (let i = 0; i < n; i++) {
            await ethers.provider.send("evm_mine", []);
        }
    }

    async function increaseTime(seconds) {
        await ethers.provider.send("evm_increaseTime", [seconds]);
        await ethers.provider.send("evm_mine", []);
    }

    async function getBlockTimestamp() {
        const block = await ethers.provider.getBlock("latest");
        return block.timestamp;
    }

    before(async function () {
        // Reset network state for test isolation
        await network.provider.send("hardhat_reset");

        [owner, user0, user1, user2, attacker, treasury, team] = await ethers.getSigners();

        // Deploy base contracts
        const WETH9 = await ethers.getContractFactory("MockWETH");
        WETH = await WETH9.deploy();
        await WETH.deployed();

        const DONUT_ERC20 = await ethers.getContractFactory("MockWETH");
        DONUT = await DONUT_ERC20.deploy();
        await DONUT.deployed();

        const UniFactory = await ethers.getContractFactory("MockUniswapV2Factory");
        uniFactory = await UniFactory.deploy();
        await uniFactory.deployed();

        const UniRouter = await ethers.getContractFactory("MockUniswapV2Router");
        uniRouter = await UniRouter.deploy(uniFactory.address);
        await uniRouter.deployed();

        const RigFactory = await ethers.getContractFactory("RigFactory");
        rigFactory = await RigFactory.deploy();
        await rigFactory.deployed();

        const AuctionFactory = await ethers.getContractFactory("AuctionFactory");
        auctionFactory = await AuctionFactory.deploy();
        await auctionFactory.deployed();

        const UnitFactory = await ethers.getContractFactory("UnitFactory");
        const unitFactory = await UnitFactory.deploy();
        await unitFactory.deployed();

        const Core = await ethers.getContractFactory("Core");
        core = await Core.deploy(
            WETH.address,
            DONUT.address,
            uniFactory.address,
            uniRouter.address,
            unitFactory.address,
            rigFactory.address,
            auctionFactory.address,
            owner.address,
            convert("100", 18)
        );
        await core.deployed();

        const Multicall = await ethers.getContractFactory("Multicall");
        multicall = await Multicall.deploy(core.address, WETH.address, DONUT.address);
        await multicall.deployed();

        // Mint tokens to users
        await WETH.connect(user0).deposit({ value: convert("1000", 18) });
        await WETH.connect(user1).deposit({ value: convert("1000", 18) });
        await WETH.connect(user2).deposit({ value: convert("1000", 18) });
        await WETH.connect(attacker).deposit({ value: convert("1000", 18) });

        await DONUT.connect(user0).deposit({ value: convert("5000", 18) });
        await DONUT.connect(user1).deposit({ value: convert("2000", 18) });
        await DONUT.connect(user2).deposit({ value: convert("2000", 18) });
        await DONUT.connect(attacker).deposit({ value: convert("2000", 18) });
    });

    async function launchRig(launcher, options = {}) {
        const defaults = {
            launcher: launcher.address,
            tokenName: "Test Unit",
            tokenSymbol: "TUNIT",
            uri: "",
            donutAmount: convert("200", 18), // Reduced for test affordability
            unitAmount: convert("1000000", 18),
            initialUps: convert("4", 18),
            tailUps: convert("0.01", 18),
            halvingPeriod: 2592000,
            rigEpochPeriod: 3600,
            rigPriceMultiplier: convert("2", 18),
            rigMinInitPrice: convert("0.0001", 18),
            auctionInitPrice: convert("1", 18),
            auctionEpochPeriod: 3600,
            auctionPriceMultiplier: convert("2", 18),
            auctionMinInitPrice: convert("0.1", 18)
        };

        const params = { ...defaults, ...options };

        // Ensure launcher has DONUT
        const donutBal = await DONUT.balanceOf(launcher.address);
        if (donutBal.lt(params.donutAmount)) {
            await DONUT.connect(launcher).deposit({ value: params.donutAmount.sub(donutBal).add(convert("100", 18)) });
        }

        await DONUT.connect(launcher).approve(core.address, params.donutAmount);

        const launchParams = {
            launcher: params.launcher,
            tokenName: params.tokenName,
            tokenSymbol: params.tokenSymbol,
            uri: params.uri,
            donutAmount: params.donutAmount,
            unitAmount: params.unitAmount,
            initialUps: params.initialUps,
            tailUps: params.tailUps,
            halvingPeriod: params.halvingPeriod,
            rigEpochPeriod: params.rigEpochPeriod,
            rigPriceMultiplier: params.rigPriceMultiplier,
            rigMinInitPrice: params.rigMinInitPrice,
            auctionInitPrice: params.auctionInitPrice,
            auctionEpochPeriod: params.auctionEpochPeriod,
            auctionPriceMultiplier: params.auctionPriceMultiplier,
            auctionMinInitPrice: params.auctionMinInitPrice
        };

        const tx = await core.connect(launcher).launch(launchParams);

        const receipt = await tx.wait();
        const launchEvent = receipt.events.find(e => e.event === "Core__Launched");
        const rigAddr = launchEvent.args.rig;

        const rigContract = await ethers.getContractAt("Rig", rigAddr);
        const unitAddr = await rigContract.unit();
        const unitContract = await ethers.getContractAt("Unit", unitAddr);
        const auctionAddr = await core.rigToAuction(rigAddr);
        const auctionContract = await ethers.getContractAt("Auction", auctionAddr);
        const lpTokenAddr = await auctionContract.paymentToken();

        return { rig: rigContract, unit: unitContract, auction: auctionContract, lpToken: lpTokenAddr };
    }

    describe("Price Manipulation Attacks", function () {
        beforeEach(async function () {
            const contracts = await launchRig(user0);
            rig = contracts.rig;
            unit = contracts.unit;
        });

        it("EXPLOIT: Precision loss in price calculation for tiny initPrice", async function () {
            // Launch rig with minimum possible initPrice
            const { rig: tinyRig } = await launchRig(user0, { rigMinInitPrice: 1e6 }); // ABS_MIN_INIT_PRICE

            // Check price at various time points
            const initPrice = await tinyRig.epochInitPrice();
            const epochPeriod = await tinyRig.epochPeriod();

            // At midpoint: initPrice - (initPrice * (epochPeriod/2)) / epochPeriod
            // = initPrice - initPrice/2 = 0 (due to integer division when initPrice=1)
            await increaseTime(epochPeriod.div(2).toNumber());
            const midPrice = await tinyRig.getPrice();

            // For initPrice=1, at midpoint: 1 - 1*1800/3600 = 1 - 0 = 1 (rounds down)
            console.log(`    Init price: ${initPrice.toString()}`);
            console.log(`    Mid price: ${midPrice.toString()}`);

            // Verify price doesn't drop to 0 prematurely due to rounding
            // This could allow free mining
            expect(midPrice.gte(0)).to.be.true;
        });

        it("EXPLOIT: Price decay at exact epoch boundary", async function () {
            const epochPeriod = await rig.epochPeriod();

            // Advance exactly to epoch period
            await increaseTime(epochPeriod.toNumber());

            const price = await rig.getPrice();
            expect(price).to.equal(0);

            // Mine at zero price - is this intended?
            const deadline = await getFutureDeadline();
            await WETH.connect(user1).approve(rig.address, convert("1", 18));
            await rig.connect(user1).mine(user1.address, 0, deadline, convert("1", 18), "zero-price-mine");

            // User1 got rig for free (no payment)
            expect(await rig.epochMiner()).to.equal(user1.address);
        });

        it("EXPLOIT: Price overflow via large priceMultiplier", async function () {
            // Launch with max reasonable multiplier (10x)
            const { rig: highMultRig } = await launchRig(user0, {
                priceMultiplier: convert("10", 18),
                minInitPrice: convert("1000", 18) // Start high
            });

            // Mine many times and watch price grow
            for (let i = 0; i < 5; i++) {
                const deadline = await getFutureDeadline();
                const price = await highMultRig.getPrice();
                await WETH.connect(user1).approve(highMultRig.address, price.add(convert("1", 18)));

                if (price.gt(0)) {
                    try {
                        await highMultRig.connect(user1).mine(user1.address, i, deadline, price, `mine-${i}`);
                    } catch (e) {
                        console.log(`    Failed at iteration ${i}: ${e.message}`);
                        break;
                    }
                }
            }

            // Check final price - should be capped at ABS_MAX_INIT_PRICE
            const finalPrice = await highMultRig.epochInitPrice();
            console.log(`    Final init price: ${ethers.utils.formatEther(finalPrice)} ETH`);
        });
    });

    describe("Fee Distribution Attacks", function () {
        beforeEach(async function () {
            const contracts = await launchRig(user0);
            rig = contracts.rig;
            unit = contracts.unit;
        });

        it("EXPLOIT: Self-mining to extract value", async function () {
            // First, become the miner
            const deadline = await getFutureDeadline();
            const price1 = await rig.getPrice();
            await WETH.connect(attacker).approve(rig.address, price1);
            await rig.connect(attacker).mine(attacker.address, 0, deadline, price1, "become-rig");

            const attackerBalBefore = await WETH.balanceOf(attacker.address);
            const attackerUnitBefore = await unit.balanceOf(attacker.address);

            // Wait some time to accumulate tokens
            await increaseTime(1800); // Half epoch

            // Mine to self - paying price but getting 80% back
            const deadline2 = await getFutureDeadline();
            const price2 = await rig.getPrice();
            await WETH.connect(attacker).approve(rig.address, price2);
            await rig.connect(attacker).mine(attacker.address, 1, deadline2, price2, "self-mine");

            const attackerBalAfter = await WETH.balanceOf(attacker.address);
            const attackerUnitAfter = await unit.balanceOf(attacker.address);

            // Calculate net loss/gain
            const wethLoss = attackerBalBefore.sub(attackerBalAfter);
            const unitGained = attackerUnitAfter.sub(attackerUnitBefore);

            console.log(`    WETH paid (net): ${ethers.utils.formatEther(wethLoss)} (20% of price)`);
            console.log(`    Unit tokens gained: ${ethers.utils.formatEther(unitGained)}`);

            // Attacker loses 20% of price but gains Unit tokens
            // This is expected behavior, not an exploit
            expect(wethLoss).to.be.gt(0);
            expect(unitGained).to.be.gt(0);
        });

        it("EXPLOIT: Fee rounding dust accumulation", async function () {
            // Mine many times with small amounts and check if dust accumulates
            const treasuryBalBefore = await WETH.balanceOf(treasury.address);
            const teamBalBefore = await WETH.balanceOf(team.address);

            for (let i = 0; i < 10; i++) {
                // Let price decay to a small value
                await increaseTime(3500); // Near end of epoch

                const deadline = await getFutureDeadline();
                const price = await rig.getPrice();

                if (price.gt(0)) {
                    await WETH.connect(user1).approve(rig.address, price);
                    await rig.connect(user1).mine(user1.address, i, deadline, price, `dust-${i}`);
                }
            }

            const treasuryBalAfter = await WETH.balanceOf(treasury.address);
            const teamBalAfter = await WETH.balanceOf(team.address);

            // Verify fees were distributed (even small amounts)
            console.log(`    Treasury gained: ${ethers.utils.formatEther(treasuryBalAfter.sub(treasuryBalBefore))}`);
            console.log(`    Team gained: ${ethers.utils.formatEther(teamBalAfter.sub(teamBalBefore))}`);
        });

        it("EXPLOIT: Protocol fee calculation uses remainder", async function () {
            // Protocol gets: price - 80% - 15% - 4% = 1%
            // But due to integer division, could be slightly different

            const deadline = await getFutureDeadline();
            const price = await rig.getPrice();

            const protocolFeeAddr = await core.protocolFeeAddress();
            const protocolBalBefore = await WETH.balanceOf(protocolFeeAddr);

            await WETH.connect(user1).approve(rig.address, price);
            await rig.connect(user1).mine(user1.address, 0, deadline, price, "protocol-test");

            const protocolBalAfter = await WETH.balanceOf(protocolFeeAddr);
            const protocolReceived = protocolBalAfter.sub(protocolBalBefore);

            // Calculate expected 1%
            const expected1Percent = price.mul(100).div(10000);

            console.log(`    Price: ${ethers.utils.formatEther(price)}`);
            console.log(`    Protocol received: ${ethers.utils.formatEther(protocolReceived)}`);
            console.log(`    Expected 1%: ${ethers.utils.formatEther(expected1Percent)}`);

            // Protocol gets remainder after 80% + 15% + 4% = 99% distributed
            // Due to integer division, remainder could be slightly less than 1%
            // This is expected behavior - no exploit here
            expect(protocolReceived).to.be.gt(0);
        });
    });

    describe("Reentrancy Attacks", function () {
        it("SECURITY: Rig uses nonReentrant modifier", async function () {
            // The Rig uses SafeERC20 and nonReentrant on mine()
            // This prevents reentrancy via malicious ERC20 callbacks
            // Verification: The mine function has nonReentrant modifier

            // This is a code review check - the contract is protected
            // Cannot directly test reentrancy without malicious quote token
            // but the nonReentrant modifier on mine() prevents this attack vector
        });

        it("SECURITY: State updates after external calls are protected", async function () {
            // State updates (epochId++, initPrice, epochStartTime, miner, ups, uri)
            // happen after safeTransferFrom calls
            // This is a classic reentrancy vector, but nonReentrant prevents exploitation
            // Even if ERC777 tokens with receive hooks were used, the guard protects

            // The order in mine():
            // 1. safeTransferFrom x4 (external calls)
            // 2. Unit.mint (external call)
            // 3. State updates
            // nonReentrant protects this entire sequence
        });
    });

    describe("Token Minting Attacks", function () {
        beforeEach(async function () {
            const contracts = await launchRig(user0);
            rig = contracts.rig;
            unit = contracts.unit;
        });

        it("EXPLOIT: Mint inflation via rapid epoch cycling", async function () {
            let totalMinted = ethers.BigNumber.from(0);

            // Mine rapidly 20 times
            for (let i = 0; i < 20; i++) {
                const deadline = await getFutureDeadline();
                const price = await rig.getPrice();

                await WETH.connect(user1).approve(rig.address, price.add(convert("1", 18)));
                const tx = await rig.connect(user1).mine(user1.address, i, deadline, price, `rapid-${i}`);

                const receipt = await tx.wait();
                const mintEvent = receipt.events.find(e => e.event === "Rig__Minted");
                if (mintEvent) {
                    totalMinted = totalMinted.add(mintEvent.args.amount);
                }
            }

            console.log(`    Total minted in 20 rapid mines: ${ethers.utils.formatEther(totalMinted)}`);

            // Rapid mining shouldn't mint many tokens since time between mines is minimal
            // Most epochs should mint near-zero tokens
        });

        it("EXPLOIT: Flash mine - mine at exact same block timestamp", async function () {
            // Try to mine twice in "same block" (same timestamp conceptually)
            const deadline = await getFutureDeadline();
            const price = await rig.getPrice();

            await WETH.connect(user1).approve(rig.address, price);
            await rig.connect(user1).mine(user1.address, 0, deadline, price, "first");

            // Immediately try second mine
            const price2 = await rig.getPrice();
            await WETH.connect(user2).approve(rig.address, price2.add(convert("1", 18)));

            const deadline2 = await getFutureDeadline();
            await rig.connect(user2).mine(user2.address, 1, deadline2, price2, "second");

            // Check if second mine got zero tokens (since no time passed)
            const unitBalance = await unit.balanceOf(user1.address);
            console.log(`    User1 (first miner) got: ${ethers.utils.formatEther(unitBalance)} tokens`);

            // Second mine should mint near-zero to first miner
        });

        it("EXPLOIT: Maximum UPS exploitation", async function () {
            // Launch with maximum practical UPS
            const { rig: maxUpsRig, unit: maxUnit } = await launchRig(user0, {
                initialUps: convert("1000000", 18), // 1M tokens per second
                tailUps: convert("1", 18)
            });

            // Mine, wait, mine again
            const deadline = await getFutureDeadline();
            const price = await maxUpsRig.getPrice();
            await WETH.connect(user1).approve(maxUpsRig.address, price);
            await maxUpsRig.connect(user1).mine(user1.address, 0, deadline, price, "max-ups-1");

            // Wait 10 seconds
            await increaseTime(10);

            const deadline2 = await getFutureDeadline();
            const price2 = await maxUpsRig.getPrice();
            await WETH.connect(user2).approve(maxUpsRig.address, price2.add(convert("1", 18)));
            await maxUpsRig.connect(user2).mine(user2.address, 1, deadline2, price2, "max-ups-2");

            const minted = await maxUnit.balanceOf(user1.address);
            console.log(`    Minted with 1M UPS over ~10s: ${ethers.utils.formatEther(minted)}`);

            // Should be ~10M tokens (1M/s * 10s)
            expect(minted).to.be.gt(convert("1000000", 18)); // At least 1M
        });
    });

    describe("Halving Schedule Attacks", function () {
        it("EXPLOIT: Extreme halving count (UPS approaches zero)", async function () {
            // Launch with settings that cause many halvings (within new bounds)
            const { rig: halvRig, unit: halvUnit } = await launchRig(user0, {
                initialUps: convert("1000000", 18), // 1M tokens/s (at MAX_INITIAL_UPS)
                tailUps: convert("1", 18), // Low tail
                halvingPeriod: 86400 // 1 day halvings (MIN_HALVING_PERIOD)
            });

            // Jump forward many halving periods (20 days)
            // After 20 halvings: 1000000 >> 20 = ~0.95
            await increaseTime(86400 * 20);

            const currentUps = await halvRig.getUps();
            console.log(`    UPS after 20 halvings: ${ethers.utils.formatEther(currentUps)}`);

            // Should be at tailUps now
            expect(currentUps).to.equal(convert("1", 18));
        });

        it("EXPLOIT: Halving exactly at boundary", async function () {
            const { rig: boundaryRig } = await launchRig(user0, {
                halvingPeriod: 86400 // 1 day (MIN_HALVING_PERIOD)
            });

            // Get initial UPS
            const initialUps = await boundaryRig.epochUps();

            // Move to exactly halving boundary
            await increaseTime(86400);

            const upsAtBoundary = await boundaryRig.getUps();
            console.log(`    Initial UPS: ${ethers.utils.formatEther(initialUps)}`);
            console.log(`    UPS at halving boundary: ${ethers.utils.formatEther(upsAtBoundary)}`);

            // UPS should be halved
            expect(upsAtBoundary).to.equal(initialUps.div(2));
        });

        it("EXPLOIT: UPS underflow with tailUps = 0", async function () {
            // Core should prevent this - verify the validation works
            const launchParams = {
                launcher: user0.address,
                    tokenName: "Test Unit",
                tokenSymbol: "TUNIT",
                uri: "",
                donutAmount: convert("200", 18),
                unitAmount: convert("1000000", 18),
                initialUps: convert("4", 18),
                tailUps: 0, // Invalid
                halvingPeriod: 2592000,
                rigEpochPeriod: 3600,
                rigPriceMultiplier: convert("2", 18),
                rigMinInitPrice: convert("0.0001", 18),
                auctionInitPrice: convert("1", 18),
                auctionEpochPeriod: 3600,
                auctionPriceMultiplier: convert("2", 18),
                auctionMinInitPrice: convert("0.1", 18)
            };

            await DONUT.connect(user0).approve(core.address, convert("200", 18));
            await expect(
                core.connect(user0).launch(launchParams)
            ).to.be.revertedWith("Rig__InvalidTailUps()");
        });
    });

    describe("Frontrunning and MEV Attacks", function () {
        beforeEach(async function () {
            const contracts = await launchRig(user0);
            rig = contracts.rig;
            unit = contracts.unit;
        });

        it("EXPLOIT: Frontrun victim's mine with same epochId", async function () {
            const epochId = await rig.epochId();
            const deadline = await getFutureDeadline();
            const price = await rig.getPrice();

            // Victim prepares transaction
            await WETH.connect(user1).approve(rig.address, price);

            // Attacker frontruns
            await WETH.connect(attacker).approve(rig.address, price);
            await rig.connect(attacker).mine(attacker.address, epochId, deadline, price, "frontrun");

            // Victim's transaction now fails due to epochId mismatch
            await expect(
                rig.connect(user1).mine(user1.address, epochId, deadline, price, "victim")
            ).to.be.revertedWith("Rig__EpochIdMismatch()");
        });

        it("EXPLOIT: Sandwich attack on price", async function () {
            // Attacker sees victim's transaction in mempool
            // Attacker mines first, then victim pays higher price

            const deadline = await getFutureDeadline();
            const initialPrice = await rig.getPrice();

            // Attacker mines first
            await WETH.connect(attacker).approve(rig.address, initialPrice);
            await rig.connect(attacker).mine(attacker.address, 0, deadline, initialPrice, "sandwich-front");

            // Price for next epoch is higher (priceMultiplier applied)
            const newPrice = await rig.getPrice();
            console.log(`    Initial price: ${ethers.utils.formatEther(initialPrice)}`);
            console.log(`    New price after attacker: ${ethers.utils.formatEther(newPrice)}`);

            // Victim now has to pay the new (higher) price
            // maxPrice protection helps here
            await WETH.connect(user1).approve(rig.address, initialPrice);
            await expect(
                rig.connect(user1).mine(user1.address, 1, deadline, initialPrice, "victim")
            ).to.be.revertedWith("Rig__MaxPriceExceeded()");
        });

        it("PROTECTION: maxPrice slippage protection works", async function () {
            // Launch fresh rig to ensure known state
            const { rig: freshRig } = await launchRig(user1);

            const deadline = await getFutureDeadline();
            const currentPrice = await freshRig.getPrice();

            // Try to mine with maxPrice = 0 when price > 0
            await WETH.connect(user2).approve(freshRig.address, currentPrice);
            await expect(
                freshRig.connect(user2).mine(user2.address, 0, deadline, 0, "low-max")
            ).to.be.revertedWith("Rig__MaxPriceExceeded()");
        });

        it("PROTECTION: deadline protection works", async function () {
            const pastDeadline = (await getBlockTimestamp()) - 1;
            const price = await rig.getPrice();

            await WETH.connect(user1).approve(rig.address, price);
            await expect(
                rig.connect(user1).mine(user1.address, 0, pastDeadline, price, "expired")
            ).to.be.revertedWith("Rig__Expired()");
        });
    });

    describe("Access Control Attacks", function () {
        beforeEach(async function () {
            const contracts = await launchRig(user0);
            rig = contracts.rig;
            unit = contracts.unit;
        });

        it("EXPLOIT: Non-owner cannot change treasury", async function () {
            await expect(
                rig.connect(attacker).setTreasury(attacker.address)
            ).to.be.revertedWith("Ownable: caller is not the owner");
        });

        it("EXPLOIT: Non-owner cannot change team", async function () {
            await expect(
                rig.connect(attacker).setTeam(attacker.address)
            ).to.be.revertedWith("Ownable: caller is not the owner");
        });

        it("EXPLOIT: Cannot set treasury to zero", async function () {
            await expect(
                rig.connect(user0).setTreasury(ethers.constants.AddressZero)
            ).to.be.revertedWith("Rig__InvalidTreasury()");
        });

        it("EXPLOIT: Attacker mines with rig=contract address", async function () {
            const deadline = await getFutureDeadline();
            const price = await rig.getPrice();

            await WETH.connect(attacker).approve(rig.address, price);

            // Setting rig to be a contract address is allowed
            // Tokens will be minted to that contract (if it can receive ERC20)
            await rig.connect(attacker).mine(rig.address, 0, deadline, price, "contract-rig");

            // The Rig contract is now the miner
            expect(await rig.epochMiner()).to.equal(rig.address);

            // Tokens will be minted to Rig contract on next mine
            // These tokens would be stuck unless Rig has transfer functionality
        });

        it("RECOVERY: Rig is not permanently bricked if miner is set to Rig address", async function () {
            // 1) First mine: set miner to the Rig contract address
            const deadline1 = await getFutureDeadline();
            const price1 = await rig.getPrice();
            await WETH.connect(attacker).approve(rig.address, price1);
            await rig.connect(attacker).mine(rig.address, 0, deadline1, price1, "set-rig-as-miner");
            expect(await rig.epochMiner()).to.equal(rig.address);

            // 2) Second mine: someone else takes over successfully (previous miner = Rig)
            // Advance time to ensure non-zero minting to previous miner (Rig)
            await increaseTime(10);

            const epochId1 = await rig.epochId(); // should be 1
            const price2 = await rig.getPrice();
            const deadline2 = await getFutureDeadline();
            await WETH.connect(user1).approve(rig.address, price2);
            const tx2 =
                await rig.connect(user1).mine(user1.address, epochId1, deadline2, price2, "recover-from-rig-miner");
            const receipt2 = await tx2.wait();
            expect(await rig.epochMiner()).to.equal(user1.address);

            // When Rig was the previous miner, it receives the previous-miner fee.
            // With the current payment flow, this ends up stuck in the Rig (no withdrawal path).
            const minedEvent2 = receipt2.events.find((e) => e.event === "Rig__Mined");
            const previousMinerFeeEvent2 = receipt2.events.find((e) => e.event === "Rig__PreviousMinerFee");

            expect(minedEvent2).to.not.equal(undefined);
            expect(previousMinerFeeEvent2).to.not.equal(undefined);
            expect(previousMinerFeeEvent2.args.miner).to.equal(rig.address);

            const actualPrice2 = minedEvent2.args.price;
            expect(previousMinerFeeEvent2.args.amount).to.equal(actualPrice2.mul(8000).div(10000));

            const expectedStuckWeth = previousMinerFeeEvent2.args.amount;
            expect(await WETH.balanceOf(rig.address)).to.equal(expectedStuckWeth);

            // 3) Third mine: prove the Rig continues to operate normally even with stuck WETH
            await increaseTime(10);

            const epochId2 = await rig.epochId(); // should be 2
            const price3 = await rig.getPrice();
            const deadline3 = await getFutureDeadline();
            await WETH.connect(user2).approve(rig.address, price3);
            await rig.connect(user2).mine(user2.address, epochId2, deadline3, price3, "continue-after-recovery");
            expect(await rig.epochMiner()).to.equal(user2.address);

            // Stuck WETH should remain unchanged (subsequent mines should not affect it)
            expect(await WETH.balanceOf(rig.address)).to.equal(expectedStuckWeth);
        });
    });

    describe("State Manipulation Attacks", function () {
        beforeEach(async function () {
            const contracts = await launchRig(user0);
            rig = contracts.rig;
            unit = contracts.unit;
        });

        it("EXPLOIT: epochId overflow", async function () {
            // epochId uses unchecked increment
            // Would need 2^256 mines to overflow - practically impossible
            // Just verify the unchecked block is there for gas savings
            const epochId = await rig.epochId();
            expect(epochId).to.equal(0);
        });

        it("EXPLOIT: Manipulate epochStartTime via block.timestamp", async function () {
            // Miners can manipulate timestamp by ~15 seconds
            // This could affect price calculation slightly
            const epochStartTime = await rig.epochStartTime();
            const blockTimestamp = await getBlockTimestamp();

            // epochStartTime should be close to block timestamp
            const diff = epochStartTime.toNumber() - blockTimestamp;
            expect(Math.abs(diff)).to.be.lessThan(100);
        });

        it("EXPLOIT: Free tokens by waiting infinite time", async function () {
            // Wait a very long time (1 year)
            await increaseTime(365 * 24 * 3600);

            // Mine at zero price
            const deadline = await getFutureDeadline();
            const price = await rig.getPrice();
            expect(price).to.equal(0);

            const miner = await rig.epochMiner();
            const rigBalBefore = await unit.balanceOf(miner);

            await WETH.connect(user1).approve(rig.address, convert("1", 18));
            await rig.connect(user1).mine(user1.address, 0, deadline, convert("1", 18), "free-tokens");

            const rigBalAfter = await unit.balanceOf(miner);
            const tokensGained = rigBalAfter.sub(rigBalBefore);

            console.log(`    Tokens minted after 1 year idle: ${ethers.utils.formatEther(tokensGained)}`);

            // Even though mining was free, tokens were minted based on time held
            // This is expected behavior - whoever holds the rig earns tokens over time
            // But UPS would have gone through many halvings, reducing emission
        });
    });

    describe("Edge Case Attacks", function () {
        it("PROTECTION: Cannot launch with minInitPrice = 0", async function () {
            // Rig now enforces ABS_MIN_INIT_PRICE = 1 wei
            // This prevents perpetual free mining exploit

            // Ensure attacker has fresh DONUT for this test
            await DONUT.connect(attacker).deposit({ value: convert("300", 18) });

            const launchParams = {
                launcher: attacker.address,
                    tokenName: "Zero Min Test",
                tokenSymbol: "ZMT",
                uri: "",
                donutAmount: convert("200", 18),
                unitAmount: convert("1000000", 18),
                initialUps: convert("4", 18),
                tailUps: convert("0.01", 18),
                halvingPeriod: 2592000,
                rigEpochPeriod: 3600,
                rigPriceMultiplier: convert("2", 18),
                rigMinInitPrice: 0, // Invalid - below ABS_MIN_INIT_PRICE
                auctionInitPrice: convert("1", 18),
                auctionEpochPeriod: 3600,
                auctionPriceMultiplier: convert("2", 18),
                auctionMinInitPrice: convert("0.1", 18)
            };

            await DONUT.connect(attacker).approve(core.address, convert("200", 18));
            await expect(
                core.connect(attacker).launch(launchParams)
            ).to.be.revertedWith("Rig__MinInitPriceBelowAbsoluteMin()");
        });

        it("EXPLOIT: Very long URI string", async function () {
            const { rig: uriRig } = await launchRig(user0);

            // Create very long URI (gas griefing)
            const longUri = "x".repeat(10000);

            const deadline = await getFutureDeadline();
            const price = await uriRig.getPrice();

            await WETH.connect(user1).approve(uriRig.address, price);

            // This should work but cost more gas
            const tx = await uriRig.connect(user1).mine(user1.address, 0, deadline, price, longUri);
            const receipt = await tx.wait();

            console.log(`    Gas used with 10k char URI: ${receipt.gasUsed.toString()}`);

            // Long URIs are stored in storage, costing gas
            // This is a mild griefing vector but attacker pays the gas
        });

        it("EXPLOIT: Mine with rig = msg.sender", async function () {
            // Common pattern that should work fine
            const { rig: selfRig, unit: selfUnit } = await launchRig(user0);

            const deadline = await getFutureDeadline();
            const price = await selfRig.getPrice();

            await WETH.connect(user1).approve(selfRig.address, price);
            await selfRig.connect(user1).mine(user1.address, 0, deadline, price, "self");

            expect(await selfRig.epochMiner()).to.equal(user1.address);
        });
    });

    describe("Token Value Extraction Attacks", function () {
        it("EXPLOIT: Extract value by becoming miner then abandoning", async function () {
            const { rig: valRig, unit: valUnit } = await launchRig(user0);

            const deadline = await getFutureDeadline();
            const price = await valRig.getPrice();

            // Attacker becomes miner
            await WETH.connect(attacker).approve(valRig.address, price);
            await valRig.connect(attacker).mine(attacker.address, 0, deadline, price, "extract");

            // Wait for time to pass
            await increaseTime(1800);

            // Check accumulated value (UPS * time)
            const ups = await valRig.epochUps();
            const elapsed = 1800;
            const expectedTokens = ups.mul(elapsed);

            console.log(`    Expected tokens: ${ethers.utils.formatEther(expectedTokens)}`);

            // If no one else mines, attacker accumulates tokens indefinitely
            // But they don't receive them until someone else mines
            // If no one ever mines again, tokens are never distributed
        });

        it("VERIFICATION: Tokens only distributed on next mine", async function () {
            const { rig: distRig, unit: distUnit } = await launchRig(user0);

            const deadline = await getFutureDeadline();
            const price = await distRig.getPrice();

            // User1 becomes miner
            await WETH.connect(user1).approve(distRig.address, price);
            await distRig.connect(user1).mine(user1.address, 0, deadline, price, "first");

            const user1BalBefore = await distUnit.balanceOf(user1.address);

            // Wait
            await increaseTime(1800);

            // User1 still has same balance (no auto-distribution)
            const user1BalStill = await distUnit.balanceOf(user1.address);
            expect(user1BalStill).to.equal(user1BalBefore);

            // Only when user2 mines does user1 receive tokens
            const deadline2 = await getFutureDeadline();
            const price2 = await distRig.getPrice();
            await WETH.connect(user2).approve(distRig.address, price2.add(convert("1", 18)));
            await distRig.connect(user2).mine(user2.address, 1, deadline2, price2, "second");

            const user1BalAfter = await distUnit.balanceOf(user1.address);
            expect(user1BalAfter).to.be.gt(user1BalBefore);

            console.log(`    User1 received: ${ethers.utils.formatEther(user1BalAfter.sub(user1BalBefore))} tokens`);
        });
    });

    describe("Integration Attack Scenarios", function () {
        it("EXPLOIT: Coordinated attack - deplete rig value", async function () {
            // Two attackers coordinate to extract value
            const { rig: coordRig, unit: coordUnit } = await launchRig(user0);

            // Attacker1 mines first
            let deadline = await getFutureDeadline();
            let price = await coordRig.getPrice();
            await WETH.connect(attacker).approve(coordRig.address, price);
            await coordRig.connect(attacker).mine(attacker.address, 0, deadline, price, "a1");

            // Wait for tokens to accumulate
            await increaseTime(1800);

            // Attacker2 (simulated as user2) mines, sending tokens to attacker1
            deadline = await getFutureDeadline();
            price = await coordRig.getPrice();
            await WETH.connect(user2).approve(coordRig.address, price.add(convert("1", 18)));
            await coordRig.connect(user2).mine(user2.address, 1, deadline, price, "a2");

            const attackerTokens = await coordUnit.balanceOf(attacker.address);
            console.log(`    Attacker gained: ${ethers.utils.formatEther(attackerTokens)} tokens`);

            // This is normal operation - not really an attack
            // Attacker paid for their position and earned tokens for time held
        });

        it("VERIFICATION: Gas griefing via many small mines", async function () {
            const { rig: gasRig } = await launchRig(user0, { rigMinInitPrice: 1e6 });

            const gasCosts = [];

            // Perform multiple mines and track gas
            for (let i = 0; i < 5; i++) {
                const deadline = await getFutureDeadline();
                const price = await gasRig.getPrice();

                await WETH.connect(user1).approve(gasRig.address, convert("1", 18));
                const tx = await gasRig.connect(user1).mine(user1.address, i, deadline, convert("1", 18), `gas-${i}`);
                const receipt = await tx.wait();
                gasCosts.push(receipt.gasUsed.toNumber());
            }

            console.log(`    Gas costs: ${gasCosts.join(", ")}`);

            // Gas should be relatively constant (no unbounded loops)
            // First mine is more expensive (cold storage), subsequent are cheaper
            const maxGas = Math.max(...gasCosts);
            const minGas = Math.min(...gasCosts);
            // After first mine, variance should be low (no O(n) operations)
            const subsequentGasCosts = gasCosts.slice(1);
            const maxSubsequent = Math.max(...subsequentGasCosts);
            const minSubsequent = Math.min(...subsequentGasCosts);
            expect(maxSubsequent - minSubsequent).to.be.lt(50000); // Variance should be low after warm-up
        });
    });

    describe("Critical Vulnerability Checks", function () {
        it("CHECK: No way to drain contract funds", async function () {
            const { rig: drainRig } = await launchRig(user0);

            // Rig doesn't hold funds - it transfers directly
            const rigBalance = await WETH.balanceOf(drainRig.address);
            expect(rigBalance).to.equal(0);

            // All payments go directly to recipients via safeTransferFrom
        });

        it("CHECK: No selfdestruct vulnerability", async function () {
            // Solidity 0.8.19 - selfdestruct is deprecated but still works
            // The contract has no selfdestruct, so funds can't be lost this way
        });

        it("CHECK: Immutables cannot be changed", async function () {
            const { rig: immutRig } = await launchRig(user0);

            // All critical parameters are immutable
            const initialUps = await immutRig.initialUps();
            const tailUps = await immutRig.tailUps();
            const epochPeriod = await immutRig.epochPeriod();
            const quote = await immutRig.quote();
            const core = await immutRig.core();

            // These cannot be changed after deployment
            expect(initialUps).to.be.gt(0);
            expect(tailUps).to.be.gt(0);
            expect(epochPeriod).to.be.gt(0);
            expect(quote).to.not.equal(ethers.constants.AddressZero);
            expect(core).to.not.equal(ethers.constants.AddressZero);
        });

        it("CHECK: Unit token can only be minted by Rig", async function () {
            const { rig: unitRig, unit: unitToken } = await launchRig(user0);

            // Attacker cannot mint tokens directly
            await expect(
                unitToken.connect(attacker).mint(attacker.address, convert("1000000", 18))
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("CHECK: Unit setRig is permanently locked after launch", async function () {
            const { rig: unitRig, unit: unitToken } = await launchRig(user0);

            // Verify rig is set to the Rig contract
            expect(await unitToken.rig()).to.equal(unitRig.address);

            // Attacker cannot change rig address
            await expect(
                unitToken.connect(attacker).setRig(attacker.address)
            ).to.be.revertedWith("Unit__NotRig()");

            // Owner cannot change rig address
            await expect(
                unitToken.connect(user0).setRig(user0.address)
            ).to.be.revertedWith("Unit__NotRig()");

            // Protocol owner cannot change rig address
            await expect(
                unitToken.connect(owner).setRig(owner.address)
            ).to.be.revertedWith("Unit__NotRig()");

            // The Rig contract has no setRig function, so it's permanently locked
            expect(unitRig.setRig).to.be.undefined;
        });

        it("CHECK: Unit setRig cannot be set to zero address", async function () {
            // Deploy fresh Unit to test setRig validation
            const UnitFactory = await ethers.getContractFactory("Unit");
            const freshUnit = await UnitFactory.connect(attacker).deploy("Test", "TST");

            // Attacker is initial rig but cannot set to zero
            await expect(
                freshUnit.connect(attacker).setRig(ethers.constants.AddressZero)
            ).to.be.revertedWith("Unit__InvalidRig()");
        });

        it("EXPLOIT: Attacker cannot hijack minting via setRig", async function () {
            const { rig: unitRig, unit: unitToken } = await launchRig(user0);

            // Get some tokens into circulation by mining
            const deadline = await getFutureDeadline();
            const price = await unitRig.getPrice();
            await WETH.connect(user1).approve(unitRig.address, price);
            await unitRig.connect(user1).mine(user1.address, 0, deadline, price, "");

            await increaseTime(60);

            const deadline2 = await getFutureDeadline();
            const price2 = await unitRig.getPrice();
            await WETH.connect(user2).approve(unitRig.address, price2.add(convert("1", 18)));
            await unitRig.connect(user2).mine(user2.address, 1, deadline2, price2, "");

            const user1BalBefore = await unitToken.balanceOf(user1.address);
            expect(user1BalBefore).to.be.gt(0);

            // Attacker tries multiple ways to hijack minting
            // 1. Direct setRig call
            await expect(
                unitToken.connect(attacker).setRig(attacker.address)
            ).to.be.revertedWith("Unit__NotRig()");

            // 2. Try to mint directly
            await expect(
                unitToken.connect(attacker).mint(attacker.address, convert("999999", 18))
            ).to.be.revertedWith("Unit__NotRig()");

            // Rig is still correctly set
            expect(await unitToken.rig()).to.equal(unitRig.address);
        });

        it("POTENTIAL ISSUE: Setting rig to non-receiver contract locks tokens", async function () {
            // Deploy a contract that can't transfer ERC20 out (no transfer function)
            const NonReceiver = await ethers.getContractFactory("MockUniswapV2Factory");
            const nonReceiver = await NonReceiver.deploy();
            await nonReceiver.deployed();

            const { rig: lockRig, unit: lockUnit } = await launchRig(user0);

            const deadline = await getFutureDeadline();
            const price = await lockRig.getPrice();

            // Mine with rig set to non-receiver
            await WETH.connect(user1).approve(lockRig.address, price);
            await lockRig.connect(user1).mine(nonReceiver.address, 0, deadline, price, "non-receiver");

            // Wait and mine again
            await increaseTime(1800);

            const deadline2 = await getFutureDeadline();
            const price2 = await lockRig.getPrice();
            await WETH.connect(user2).approve(lockRig.address, price2.add(convert("1", 18)));

            // This will mint tokens to nonReceiver contract
            // ERC20 transfers to contracts always succeed (unlike ETH)
            await lockRig.connect(user2).mine(user2.address, 1, deadline2, price2, "after-nonreceiver");

            // Tokens are now in nonReceiver and cannot be retrieved
            const lockedTokens = await lockUnit.balanceOf(nonReceiver.address);
            console.log(`    Tokens locked in non-receiver: ${ethers.utils.formatEther(lockedTokens)}`);

            // This is user error, not a vulnerability
            // Users should only set rig to addresses they control
        });
    });
});
