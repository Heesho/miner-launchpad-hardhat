const { ethers, network } = require("hardhat");
const { expect } = require("chai");

// Helper to convert human-readable amounts to wei
function convert(amount, decimals) {
    return ethers.utils.parseUnits(amount.toString(), decimals);
}

describe("Unit Token Exploit Attempts", function () {
    let owner, protocol, team, user0, user1, user2, attacker, malicious;
    let weth, donut, core, rigFactory, auctionFactory, unitFactory, multicall;
    let rig, unit, auction, lpToken;

    // Helper to get deadline
    async function getFutureDeadline() {
        const block = await ethers.provider.getBlock("latest");
        return block.timestamp + 86400 * 365;
    }

    // Helper to increase time
    async function increaseTime(seconds) {
        await network.provider.send("evm_increaseTime", [seconds]);
        await network.provider.send("evm_mine");
    }

    // Helper to mine a rig
    async function mineRig(rigContract, miner, recipient = null) {
        const epochId = await rigContract.epochId();
        const price = await rigContract.getPrice();
        const deadline = await getFutureDeadline();

        await weth.connect(miner).deposit({ value: convert("10", 18) });
        await weth.connect(miner).approve(rigContract.address, price.add(convert("1", 18)));

        await rigContract.connect(miner).mine(
            recipient || miner.address,
            epochId,
            deadline,
            price.add(convert("1", 18)),
            ""
        );
    }

    before(async function () {
        await network.provider.send("hardhat_reset");

        [owner, protocol, team, user0, user1, user2, attacker, malicious] = await ethers.getSigners();

        // Deploy base contracts
        const MockWETH = await ethers.getContractFactory("MockWETH");
        weth = await MockWETH.deploy();
        donut = await MockWETH.deploy();

        const MockFactory = await ethers.getContractFactory("MockUniswapV2Factory");
        const uniFactory = await MockFactory.deploy();

        const MockRouter = await ethers.getContractFactory("MockUniswapV2Router");
        const uniRouter = await MockRouter.deploy(uniFactory.address);

        const RigFactory = await ethers.getContractFactory("RigFactory");
        rigFactory = await RigFactory.deploy();

        const AuctionFactory = await ethers.getContractFactory("AuctionFactory");
        auctionFactory = await AuctionFactory.deploy();

        const UnitFactory = await ethers.getContractFactory("UnitFactory");
        unitFactory = await UnitFactory.deploy();

        const Core = await ethers.getContractFactory("Core");
        core = await Core.deploy(
            weth.address,
            donut.address,
            uniFactory.address,
            uniRouter.address,
            unitFactory.address,
            rigFactory.address,
            auctionFactory.address,
            protocol.address,
            convert("100", 18)
        );

        const Multicall = await ethers.getContractFactory("Multicall");
        multicall = await Multicall.deploy(core.address, weth.address, donut.address);

        // Give users DONUT and WETH
        for (const user of [user0, user1, user2, attacker, malicious]) {
            await donut.connect(user).deposit({ value: convert("1000", 18) });
            await weth.connect(user).deposit({ value: convert("100", 18) });
        }

        // Launch a rig for testing
        await donut.connect(user0).approve(core.address, convert("500", 18));
        const tx = await core.connect(user0).launch({
            launcher: user0.address,
            tokenName: "Test Unit",
            tokenSymbol: "TUNIT",
            uri: "",
            donutAmount: convert("500", 18),
            unitAmount: convert("1000000", 18),
            initialUps: convert("4", 18),
            tailUps: convert("0.01", 18),
            halvingPeriod: 2592000,
            rigEpochPeriod: 3600,
            rigPriceMultiplier: convert("2", 18),
            rigMinInitPrice: convert("0.0001", 18),
            auctionInitPrice: convert("1", 18),
            auctionEpochPeriod: 86400,
            auctionPriceMultiplier: convert("1.2", 18),
            auctionMinInitPrice: convert("0.001", 18),
        });

        const receipt = await tx.wait();
        const launchEvent = receipt.events.find(e => e.event === "Core__Launched");

        rig = await ethers.getContractAt("Rig", launchEvent.args.rig);
        unit = await ethers.getContractAt("Unit", launchEvent.args.unit);
        auction = await ethers.getContractAt("Auction", launchEvent.args.auction);
        lpToken = await ethers.getContractAt("IERC20", launchEvent.args.lpToken);
    });

    // ============================================================
    // MINT FUNCTION SECURITY
    // ============================================================
    describe("Mint Function Security", function () {
        it("EXPLOIT: Random attacker cannot mint", async function () {
            await expect(
                unit.connect(attacker).mint(attacker.address, convert("1000000", 18))
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Rig launcher cannot mint", async function () {
            await expect(
                unit.connect(user0).mint(user0.address, convert("1000000", 18))
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Protocol owner cannot mint", async function () {
            await expect(
                unit.connect(owner).mint(owner.address, convert("1000000", 18))
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Core contract cannot mint after launch", async function () {
            // Core was the initial rig but transferred rights to Rig
            // Even if we somehow call from Core's context, it should fail
            await expect(
                unit.mint(attacker.address, convert("1000000", 18))
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Team address cannot mint", async function () {
            await expect(
                unit.connect(team).mint(team.address, convert("1000000", 18))
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Cannot mint to zero address (if rig tried)", async function () {
            // This tests that even the rig follows proper ERC20 rules
            // The mint would fail on OpenZeppelin's _mint if to == address(0)
            // But since we can't call from Rig, we verify rig is correct
            expect(await unit.rig()).to.equal(rig.address);
        });

        it("EXPLOIT: Cannot mint zero amount to bypass checks", async function () {
            await expect(
                unit.connect(attacker).mint(attacker.address, 0)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Cannot mint max uint256 amount", async function () {
            await expect(
                unit.connect(attacker).mint(attacker.address, ethers.constants.MaxUint256)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Cannot mint 1 wei", async function () {
            await expect(
                unit.connect(attacker).mint(attacker.address, 1)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("VERIFY: Only Rig can mint via mining", async function () {
            const balanceBefore = await unit.balanceOf(user1.address);

            // Mine to get tokens
            await mineRig(rig, user1);
            await increaseTime(60);
            await mineRig(rig, user2);

            const balanceAfter = await unit.balanceOf(user1.address);
            expect(balanceAfter).to.be.gt(balanceBefore);
        });

        it("EXPLOIT: Multiple attackers trying simultaneously", async function () {
            const attackers = [attacker, malicious, user1, user2];

            for (const a of attackers) {
                await expect(
                    unit.connect(a).mint(a.address, convert("1", 18))
                ).to.be.revertedWith("Unit__NotRig()");
            }
        });
    });

    // ============================================================
    // SETRIG FUNCTION SECURITY
    // ============================================================
    describe("setRig Function Security", function () {
        it("EXPLOIT: Random attacker cannot call setRig", async function () {
            await expect(
                unit.connect(attacker).setRig(attacker.address)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Rig launcher cannot call setRig", async function () {
            await expect(
                unit.connect(user0).setRig(user0.address)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Protocol owner cannot call setRig", async function () {
            await expect(
                unit.connect(owner).setRig(owner.address)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Core contract cannot call setRig after transfer", async function () {
            await expect(
                unit.setRig(attacker.address)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Team cannot call setRig", async function () {
            await expect(
                unit.connect(team).setRig(team.address)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("VERIFY: Rig contract has no setRig function", async function () {
            // Verify Rig doesn't expose setRig
            expect(rig.setRig).to.be.undefined;

            // Double-check by looking at interface
            const rigInterface = rig.interface;
            const functions = Object.keys(rigInterface.functions);
            expect(functions).to.not.include("setRig(address)");
        });

        it("VERIFY: rig address is still correct after failed attacks", async function () {
            // Try multiple attacks
            await expect(unit.connect(attacker).setRig(attacker.address)).to.be.reverted;
            await expect(unit.connect(user0).setRig(user0.address)).to.be.reverted;
            await expect(unit.connect(owner).setRig(owner.address)).to.be.reverted;

            // Rig is still correct
            expect(await unit.rig()).to.equal(rig.address);
        });

        it("EXPLOIT: Try to set rig to zero address", async function () {
            await expect(
                unit.connect(attacker).setRig(ethers.constants.AddressZero)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Try to set rig to current rig (no-op attack)", async function () {
            await expect(
                unit.connect(attacker).setRig(rig.address)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Try to set rig to Unit contract itself", async function () {
            await expect(
                unit.connect(attacker).setRig(unit.address)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("EXPLOIT: Multiple signers try setRig in sequence", async function () {
            const signers = [owner, protocol, team, user0, user1, user2, attacker, malicious];

            for (const signer of signers) {
                await expect(
                    unit.connect(signer).setRig(signer.address)
                ).to.be.revertedWith("Unit__NotRig()");
            }

            // Still locked to Rig
            expect(await unit.rig()).to.equal(rig.address);
        });
    });

    // ============================================================
    // FRESH UNIT TOKEN TESTS (BEFORE SETRIG)
    // ============================================================
    describe("Fresh Unit Token (before setRig)", function () {
        let freshUnit;

        beforeEach(async function () {
            const UnitContract = await ethers.getContractFactory("Unit");
            freshUnit = await UnitContract.connect(attacker).deploy("Fresh", "FRSH");
        });

        it("Deployer is initial rig", async function () {
            expect(await freshUnit.rig()).to.equal(attacker.address);
        });

        it("Deployer can mint", async function () {
            await freshUnit.connect(attacker).mint(user1.address, convert("100", 18));
            expect(await freshUnit.balanceOf(user1.address)).to.equal(convert("100", 18));
        });

        it("Others cannot mint", async function () {
            await expect(
                freshUnit.connect(user1).mint(user1.address, convert("100", 18))
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("Deployer can call setRig", async function () {
            await freshUnit.connect(attacker).setRig(user1.address);
            expect(await freshUnit.rig()).to.equal(user1.address);
        });

        it("setRig cannot be zero address", async function () {
            await expect(
                freshUnit.connect(attacker).setRig(ethers.constants.AddressZero)
            ).to.be.revertedWith("Unit__InvalidRig()");
        });

        it("After setRig, old rig cannot mint", async function () {
            await freshUnit.connect(attacker).setRig(user1.address);

            await expect(
                freshUnit.connect(attacker).mint(attacker.address, convert("100", 18))
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("After setRig, new rig can mint", async function () {
            await freshUnit.connect(attacker).setRig(user1.address);

            await freshUnit.connect(user1).mint(user2.address, convert("100", 18));
            expect(await freshUnit.balanceOf(user2.address)).to.equal(convert("100", 18));
        });

        it("After setRig, old rig cannot call setRig again", async function () {
            await freshUnit.connect(attacker).setRig(user1.address);

            await expect(
                freshUnit.connect(attacker).setRig(attacker.address)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("New rig can call setRig again", async function () {
            await freshUnit.connect(attacker).setRig(user1.address);
            await freshUnit.connect(user1).setRig(user2.address);

            expect(await freshUnit.rig()).to.equal(user2.address);
        });

        it("Chain of setRig transfers works", async function () {
            await freshUnit.connect(attacker).setRig(user0.address);
            await freshUnit.connect(user0).setRig(user1.address);
            await freshUnit.connect(user1).setRig(user2.address);

            expect(await freshUnit.rig()).to.equal(user2.address);

            // Only user2 can mint now
            await expect(freshUnit.connect(attacker).mint(attacker.address, 1)).to.be.reverted;
            await expect(freshUnit.connect(user0).mint(user0.address, 1)).to.be.reverted;
            await expect(freshUnit.connect(user1).mint(user1.address, 1)).to.be.reverted;

            await freshUnit.connect(user2).mint(user2.address, convert("1", 18));
            expect(await freshUnit.balanceOf(user2.address)).to.equal(convert("1", 18));
        });

        it("Unit__RigSet event emitted on setRig", async function () {
            await expect(freshUnit.connect(attacker).setRig(user1.address))
                .to.emit(freshUnit, "Unit__RigSet")
                .withArgs(user1.address);
        });
    });

    // ============================================================
    // REENTRANCY AND EDGE CASES
    // ============================================================
    describe("Reentrancy and Edge Cases", function () {
        it("EXPLOIT: Reentrancy via malicious recipient in mint", async function () {
            // Even if attacker deploys a contract that tries reentrancy,
            // they can't call mint in the first place
            await expect(
                unit.connect(attacker).mint(attacker.address, convert("1", 18))
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("VERIFY: Minting emits correct event", async function () {
            // Get some mining done to trigger minting
            await mineRig(rig, attacker);
            await increaseTime(100);

            // The next mine will mint to attacker
            const tx = await (async () => {
                const epochId = await rig.epochId();
                const price = await rig.getPrice();
                const deadline = await getFutureDeadline();
                await weth.connect(user1).approve(rig.address, price.add(convert("1", 18)));
                return rig.connect(user1).mine(user1.address, epochId, deadline, price.add(convert("1", 18)), "");
            })();

            const receipt = await tx.wait();
            const mintEvent = receipt.events.find(e => e.event === "Rig__Minted");
            expect(mintEvent).to.not.be.undefined;
            expect(mintEvent.args.miner).to.equal(attacker.address);
        });

        it("VERIFY: Total supply increases only via mining", async function () {
            const supplyBefore = await unit.totalSupply();

            // Attempt attacks - none should increase supply
            await expect(unit.connect(attacker).mint(attacker.address, convert("1", 18))).to.be.reverted;
            await expect(unit.connect(user0).mint(user0.address, convert("1", 18))).to.be.reverted;

            const supplyAfterAttacks = await unit.totalSupply();
            expect(supplyAfterAttacks).to.equal(supplyBefore);

            // Mining increases supply
            await mineRig(rig, user1);
            await increaseTime(60);
            await mineRig(rig, user2);

            const supplyAfterMining = await unit.totalSupply();
            expect(supplyAfterMining).to.be.gt(supplyBefore);
        });

        it("EXPLOIT: Try to overflow total supply", async function () {
            await expect(
                unit.connect(attacker).mint(attacker.address, ethers.constants.MaxUint256)
            ).to.be.revertedWith("Unit__NotRig()");
        });
    });

    // ============================================================
    // INTEGRATION WITH CORE LAUNCH FLOW
    // ============================================================
    describe("Integration with Core Launch Flow", function () {
        it("VERIFY: Core properly transfers rig rights during launch", async function () {
            // Launch a new rig
            await donut.connect(user1).approve(core.address, convert("500", 18));
            const tx = await core.connect(user1).launch({
                launcher: user1.address,
                    tokenName: "New Unit",
                tokenSymbol: "NUNIT",
                uri: "",
                donutAmount: convert("500", 18),
                unitAmount: convert("1000000", 18),
                initialUps: convert("1", 18),
                tailUps: convert("0.001", 18),
                halvingPeriod: 86400,
                rigEpochPeriod: 3600,
                rigPriceMultiplier: convert("1.5", 18),
                rigMinInitPrice: convert("0.0001", 18),
                auctionInitPrice: convert("1", 18),
                auctionEpochPeriod: 86400,
                auctionPriceMultiplier: convert("1.1", 18),
                auctionMinInitPrice: convert("0.001", 18),
            });

            const receipt = await tx.wait();
            const launchEvent = receipt.events.find(e => e.event === "Core__Launched");

            const newRig = await ethers.getContractAt("Rig", launchEvent.args.rig);
            const newUnit = await ethers.getContractAt("Unit", launchEvent.args.unit);

            // Unit's rig is the Rig contract, not Core
            expect(await newUnit.rig()).to.equal(newRig.address);

            // Core cannot mint
            await expect(
                newUnit.mint(attacker.address, convert("1", 18))
            ).to.be.revertedWith("Unit__NotRig()");

            // Launcher cannot mint
            await expect(
                newUnit.connect(user1).mint(user1.address, convert("1", 18))
            ).to.be.revertedWith("Unit__NotRig()");

            // setRig is locked
            await expect(
                newUnit.connect(user1).setRig(user1.address)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("VERIFY: Each launched rig has isolated Unit token", async function () {
            // Launch two rigs
            await donut.connect(user2).approve(core.address, convert("1000", 18));

            const tx1 = await core.connect(user2).launch({
                launcher: user2.address,
                    tokenName: "Unit A",
                tokenSymbol: "UNITA",
                uri: "",
                donutAmount: convert("500", 18),
                unitAmount: convert("1000000", 18),
                initialUps: convert("1", 18),
                tailUps: convert("0.001", 18),
                halvingPeriod: 86400,
                rigEpochPeriod: 3600,
                rigPriceMultiplier: convert("1.5", 18),
                rigMinInitPrice: convert("0.0001", 18),
                auctionInitPrice: convert("1", 18),
                auctionEpochPeriod: 86400,
                auctionPriceMultiplier: convert("1.1", 18),
                auctionMinInitPrice: convert("0.001", 18),
            });

            const tx2 = await core.connect(user2).launch({
                launcher: user2.address,
                    tokenName: "Unit B",
                tokenSymbol: "UNITB",
                uri: "",
                donutAmount: convert("500", 18),
                unitAmount: convert("1000000", 18),
                initialUps: convert("1", 18),
                tailUps: convert("0.001", 18),
                halvingPeriod: 86400,
                rigEpochPeriod: 3600,
                rigPriceMultiplier: convert("1.5", 18),
                rigMinInitPrice: convert("0.0001", 18),
                auctionInitPrice: convert("1", 18),
                auctionEpochPeriod: 86400,
                auctionPriceMultiplier: convert("1.1", 18),
                auctionMinInitPrice: convert("0.001", 18),
            });

            const receipt1 = await tx1.wait();
            const receipt2 = await tx2.wait();

            const event1 = receipt1.events.find(e => e.event === "Core__Launched");
            const event2 = receipt2.events.find(e => e.event === "Core__Launched");

            const unitA = await ethers.getContractAt("Unit", event1.args.unit);
            const unitB = await ethers.getContractAt("Unit", event2.args.unit);
            const rigA = event1.args.rig;
            const rigB = event2.args.rig;

            // Different tokens
            expect(unitA.address).to.not.equal(unitB.address);

            // Each locked to its own Rig
            expect(await unitA.rig()).to.equal(rigA);
            expect(await unitB.rig()).to.equal(rigB);

            // Cross-rig attacks fail
            await expect(unitA.connect(user2).setRig(rigB)).to.be.revertedWith("Unit__NotRig()");
            await expect(unitB.connect(user2).setRig(rigA)).to.be.revertedWith("Unit__NotRig()");
        });
    });

    // ============================================================
    // COMPREHENSIVE ATTACK VECTORS
    // ============================================================
    describe("Comprehensive Attack Vectors", function () {
        it("ATTACK: Frontrun Core.launch to hijack Unit", async function () {
            // Even if attacker frontruns, they can't interfere with Core's atomic launch
            // Because UnitFactory.deploy + setRig happens in same transaction

            // Verify Unit is already locked
            expect(await unit.rig()).to.equal(rig.address);

            // Attacker cannot do anything
            await expect(unit.connect(attacker).setRig(attacker.address)).to.be.reverted;
            await expect(unit.connect(attacker).mint(attacker.address, 1)).to.be.reverted;
        });

        it("ATTACK: Deploy malicious contract pretending to be Rig", async function () {
            // Deploy a fake rig contract
            const FakeRig = await ethers.getContractFactory("MockWETH"); // Any contract
            const fakeRig = await FakeRig.deploy();

            // Cannot set Unit's rig to fake rig
            await expect(
                unit.connect(attacker).setRig(fakeRig.address)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("ATTACK: Use CREATE2 to predict Unit address and frontrun", async function () {
            // Even with address prediction, attacker can't do anything
            // Because Core atomically deploys and calls setRig in same tx

            // The only window is between Unit deployment and setRig call
            // But that happens within Core.launch() atomically
            expect(await unit.rig()).to.equal(rig.address);
        });

        it("ATTACK: Flash loan to accumulate voting power then attack", async function () {
            // Even with infinite tokens from flash loan, can't call restricted functions
            await expect(
                unit.connect(attacker).setRig(attacker.address)
            ).to.be.revertedWith("Unit__NotRig()");

            await expect(
                unit.connect(attacker).mint(attacker.address, convert("1", 18))
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("ATTACK: Social engineering - convince owner to call setRig", async function () {
            // Owner cannot call setRig
            await expect(
                unit.connect(owner).setRig(attacker.address)
            ).to.be.revertedWith("Unit__NotRig()");

            // Launcher cannot call setRig
            await expect(
                unit.connect(user0).setRig(attacker.address)
            ).to.be.revertedWith("Unit__NotRig()");
        });

        it("VERIFY: No backdoor functions exist", async function () {
            const unitInterface = unit.interface;
            const functionNames = Object.keys(unitInterface.functions);

            // Check no suspicious functions
            const suspiciousFunctions = [
                "setMinter",
                "changeMinter",
                "updateRig",
                "changeRig",
                "adminMint",
                "ownerMint",
                "emergencyMint",
                "backdoor",
                "upgrade",
                "proxy"
            ];

            for (const suspicious of suspiciousFunctions) {
                const found = functionNames.some(f => f.toLowerCase().includes(suspicious.toLowerCase()));
                expect(found, `Suspicious function ${suspicious} found`).to.be.false;
            }
        });

        it("VERIFY: Contract is not upgradeable", async function () {
            // Unit doesn't inherit from upgradeable patterns
            // Check by verifying no proxy-related functions
            const unitInterface = unit.interface;
            const functionNames = Object.keys(unitInterface.functions);

            expect(functionNames).to.not.include("upgradeTo(address)");
            expect(functionNames).to.not.include("upgradeToAndCall(address,bytes)");
            expect(functionNames).to.not.include("implementation()");
        });
    });

    // ============================================================
    // STATE CONSISTENCY CHECKS
    // ============================================================
    describe("State Consistency After Attacks", function () {
        it("rig address unchanged after 100 attack attempts", async function () {
            const rigBefore = await unit.rig();

            for (let i = 0; i < 100; i++) {
                const signer = [owner, protocol, team, user0, user1, user2, attacker, malicious][i % 8];
                try {
                    await unit.connect(signer).setRig(signer.address);
                } catch (e) {
                    // Expected to fail
                }
            }

            const rigAfter = await unit.rig();
            expect(rigAfter).to.equal(rigBefore);
            expect(rigAfter).to.equal(rig.address);
        });

        it("totalSupply unchanged after 100 mint attack attempts", async function () {
            const supplyBefore = await unit.totalSupply();

            for (let i = 0; i < 100; i++) {
                const signer = [owner, protocol, team, user0, user1, user2, attacker, malicious][i % 8];
                const amount = convert((i + 1).toString(), 18);
                try {
                    await unit.connect(signer).mint(signer.address, amount);
                } catch (e) {
                    // Expected to fail
                }
            }

            const supplyAfter = await unit.totalSupply();
            expect(supplyAfter).to.equal(supplyBefore);
        });

        it("Rig still functional after attacks", async function () {
            // Mining should still work
            const balanceBefore = await unit.balanceOf(user1.address);

            await mineRig(rig, user1);
            await increaseTime(120);
            await mineRig(rig, user2);

            const balanceAfter = await unit.balanceOf(user1.address);
            expect(balanceAfter).to.be.gt(balanceBefore);
        });
    });
});
